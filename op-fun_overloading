Function overloading is a feature of C++ that allows us to create multiple functions with the same name,
so long as they have different parameters. Consider the following function:

int add(int x, int y); // integer version
double add(double x, double y); // floating point version



Function return types are not considered for uniqueness

Note that the functionâ€™s return type is NOT considered when overloading functions. 
Consider the case where you want to write a function that returns a random number,
but you need a version that will return an int, and another version that will return a double.
You might be tempted to do this:

int getRandomValue();
double getRandomValue();

But the compiler will flag this as an error. These two functions have the same parameters (none), 
and consequently, the second getRandomValue() will be treated as an erroneous redeclaration of the first. 
Consequently, these functions will need to be given different names.


#include <iostream>
using namespace std;
 
class printData {
   public:
      void print(int i) {
         cout << "Printing int: " << i << endl;
      }

      void print(double  f) {
         cout << "Printing float: " << f << endl;
      }

      void print(char* c) {
         cout << "Printing character: " << c << endl;
      }
};

int main(void) {
   printData pd;
 
   // Call print to print integer
   pd.print(5);
	
   // Call print to print float
   pd.print(500.263);
	
   // Call print to print character
   pd.print("Hello C++");
 
   return 0;
}

OUTPUT--
Printing int: 5
Printing float: 500.263
Printing character: Hello C++

Making a call to an overloaded function results in one of three possible outcomes:

1) A match is found. The call is resolved to a particular overloaded function.
              void print(char *value);
              void print(int value);
              print(0); // exact match with print(int)
              Although 0 could technically match print(char*) (as a null pointer), it exactly matches print(int). 
              Thus print(int) is the best match available
              
2) No match is found. The arguments can not be matched to any overloaded function.
   If no exact match is found, C++ tries to find a match through promotion.
  
  Char, unsigned char, and short is promoted to an int.
  Unsigned short can be promoted to int or unsigned int, depending on the size of an int
  Float is promoted to double
  Enum is promoted to int

              void print(char *value);
              void print(int value);
              print('a'); // promoted to match print(int)


3) An ambiguous match is found. The arguments matched more than one overloaded function.
  If no promotion is possible, C++ tries to find a match through standard conversion. Standard conversions include:
  
  Any numeric type will match any other numeric type, including unsigned (eg. int to float)
  Enum will match the formal type of a numeric type (eg. enum to float)
  Zero will match a pointer type and numeric type (eg. 0 to char*, or 0 to float)
  A pointer will match a void pointer
  
              void print(float value);
              void print(Employee value);
              print('a'); // 'a' converted to match print(float)
	      
	      
	      

