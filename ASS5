#include <iostream>

using namespace std;

int main()
{
    int h; cin>>h;
    try{
        if (h<=5)
        {
            throw "Error1";
        }
        if (h>9){
        throw "Error 2";

        }

    }

    catch(const char msg[]){

        cout<<msg<<endl;
    }

}

##############################################################################################

Provide atleast one catch statement or else it is a compiler error.
no statements are allowed between try and catch. or compiler error
Cannot have two catches with same input paprameter. or compiler error.


int main()
{
    int h; cin>>h;
    try{
        if (h<=5)
        {
            throw 0;
        }
        if (h>9){
        throw "Error 2";

        }

    }

   /////// catch(const char msg[]){

        cout<<msg<<endl;
    }
    ///////catch(int i)
    {
        cout<<i<<endl;
    }

}



when catch and throw types are not found to be same type a terminate function is called.
The program crashes- Abnormal termination message.


int main()
{
    int h; cin>>h;
    try{
        if (h<=5)
        {
            throw 0;
        }
        if (h>9&&h<15){
        throw "Error 2";

        }
        if (h>15){
        throw 2.2;

        }
    }

    catch(const char msg[]){

        cout<<msg<<endl;
    }
    catch(int i)
    {
        cout<<i<<endl;
    }
    catch(double i)
    {
        cout<<i<<endl;
    }

}
.

catch(...)  To take all kinds of exception
This should appear at the last if you have other exceptions defined

STACK UNWINDING
All the loakl objects created after try is called and before the exception
is met is deleted and the respective destructors are called to release memory and 
avoid inconsistant data in the stack.



###############################################################################################


#include <iostream>
using namespace std;

template <class T>

void pri(const T &i)
{
    cout<<i<<endl;
}

int main()
{
    pri(3.14);
    pri(2);
    pri('c');
    return  0;
}



###########################################################################
#include <iostream>
using namespace std;

template <class T>

void pri(const T &i, const T &j)
{
    T temp;
    i=temp;
    i=j;
    j=temp;
}




int main()
{
    int arr[5]={1,2,3,4,5};
    pri(arr[1],arr[2]);
    for(int i=0;i<5;i++)
    {
        cout<<arr[i]<<endl;
    }
    return  0;
}


###########################################################################


#include <iostream>
using namespace std;
template <class T>
class Bucky{
private:
    T first,second;
public:
    Bucky(T a,T b){
        first=a;
        second=b;
    }

    T bigger();
};
template <class T>
T Bucky<T>::bigger(){
    //code for bigger
    return (first>second?first:second);
}
int main()
{

    Bucky <int>bo(4,8);
    cout<<bo.bigger();

    return 0;
}






















#include <iostream>

using namespace std;

int main()
{
    int h; cin>>h;
    try{
        if (h<=5)
        {
            throw 0;
        }
        if (h>9&&h<15){
        throw "Error 2";

        }
        if (h>15){
        throw 2.2;

        }
    }

    catch(const char msg[]){

        cout<<msg<<endl;
    }
    catch(int i)
    {
        cout<<i<<endl;
    }
    catch(double i)
    {
        cout<<i<<endl;
    }

}
.





#######################################################################
// binary_search example
#include <iostream>     // std::cout
#include <algorithm>    // std::binary_search, std::sort
#include <vector>       // std::vector

bool myfunction (int i,int j) { return (i<j); }

int main () {
  int myints[] = {1,2,3,4,5,4,3,2,1};
  std::vector<int> v(myints,myints+9);                         // 1 2 3 4 5 4 3 2 1

  // using default comparison:
  std::sort (v.begin(), v.end());

  std::cout << "looking for a 3... ";
  if (std::binary_search (v.begin(), v.end(), 3))
    std::cout << "found!\n"; else std::cout << "not found.\n";

  // using myfunction as comp:
  std::sort (v.begin(), v.end(), myfunction);

  std::cout << "looking for a 6... ";
  if (std::binary_search (v.begin(), v.end(), 6, myfunction))
    std::cout << "found!\n"; else std::cout << "not found.\n";

  return 0;
}
































